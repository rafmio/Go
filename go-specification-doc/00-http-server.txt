Веб-сервер. В Go есть встроенный веб-сервер. Можно прослеживать входящие HTTP
запросы и все это будет частью приложения. Внешний сторонний веб-сервер типа
Nginx или Apache не понадобится.

Маршутизатор HTTP запросов (servemux). Хранит связь между URL-шаблонами приложения
и соответствующими обработчиками. В приложении обычно есть один servemux,
который содержит все URL маршруты

Обработчик - MVC паттерн проектирования, обработчики напоминают контроллеры.
Они отвечают за выполнение логики приложения, а также за заголовок и тело HTTP ответа.
----------------------------------------------------------------------------
Сетевой TCP-адрес задается в формате "host:port"
Если не задать host, ":4000", то сервер будет слушать все доступные сетевые
соединения компьютера.
Если сетевых интерфейсов несколько, то нужно указать host. Обычно не нужно.

В некоторых проектах порты указываются как ":http" или ":http-alt" - именованные
порты. Go попытается соответствующий номер в файле /etc/services

Запуск приложения, варианты:
1. $ go run .
2. $ go run main.go
3. $ go run [moduleName]  // Имя заданное командой go mod init moduleName

Servmux (маршутизатор HTTP запросов) в Go поддерживает 2 типа URL-шаблонов
  - фиксированные пути - не заканчиваются '/'
  - многоуровневые пути - заканчиваются '/'

Фиксированные пути:
  "/snippet"
  "/snippet/create"
В Servmux такие шаблоны фикс.пути сопостовляются (и вызывается соотв.обраб-чик)
только тогда, когда путь URL-запроса точно совпадает с фикс.путем

Многоуровневые пути:
  "/**"
  "/static/**"
  "/static"
Шаблоны путей сопоставляются (вызывается соотв.обработчик) всякий раз, когда
начало пути URL-запроса совпадает с путем дерева
----------------------------------------------------------------------
Функции http.Handle() и http.HandleFunc() позволяют регистрацию маршрутов
без объявления самого servemux.
Где-то за кулисами эти функции регистируют свои маршруты с помощью
DefaultServeMux - обычный servemux, но инициализируетя сам по умолчанию и сохраняется
в глобальной переменной, которая в свою очередь хранится в net/http

Код меньше (на строку), но golangify.com не рекомендует использовать DefaultServeMux.
DefaultServeMux - глобальная переменная, любой пакет может получить к ней доступ,
в т.ч. сторонние пакеты, кот.использует ваше приложение. Может быть создан
backdoor для сервера.

Лучше использовать свой servemux с локальной областью видимости.

Особенности servemux:
  - в servemux более длинные проверочные URL-шаблоны, а они обладают приоритетом
    перед короткими
  - URL-пути запросов автоматически очищаются. Если путь запроса содержит
    '.' или '..' или повторяющиеся '/' - пользователь будет автоматически
    перенаправлен на эквивалентный чистый URL. Например на
    запрос '/foo/bar/..//baz' он получит ответ 301 Permanent Redirect и будет
    направлен на '/foo/baz'
  - Если многоуровневый путь зареган и HTTP запрос получен для этого пути без
    слеша в конце('/foo'), то пользователь будет перенаправлен через
    301 Permanent Redirect на многоуровневый '/foo/'

----------------------------------------------------------------------
Вызвать метод http.ResponseWriter.WriteHeader() в обработчике можно только
один раз. После возвращения кода состояни HTTP изменить его нельзя.
Go выдаст ошибку при попытке вызвать http.ResponseWriter.WriteHeader() второй
раз.

Если вызывать http.ResponseWriter.WriteHeader() напрямую, тогда первый вызов
w.Write() автоматически отправит пользователю код состояния 200OK.
Поэтому если нужно вернуть другой код состония, нужно вызвать один раз метод
http.ResponseWriter.WriteHeader() перед любым вызовом w.Write

----------------------------------------------------------------------
На практике мало кто вызывает напрямую w.Write(), w.WriteHeader, в основном
это делается через другие функции

Для добавления нового заголовка в карту HTTP заголовков изспользуется
метод w.Header().Set()
Есть еще и методы Add(), Del(), Get()

----------------------------------------------------------------------

При отправке ответа Go автоматически устанавливает 3 сгенерированных системой
HTTP заголовка::
  - Date
  - Content-Length
  - Content-Type

Go автоматически пытается узнать тип контента с пом.ф-ции http.DetectContentType().
Если не сможет  - укажет заначениеЖ Content-Type: application/octet-stream.
Проблема: http.DetectContentType() не может отличить JSON от обычного текста.
По умолчанию будет Content-Type: text/plain; charset=utf-8.
Можно предотвратить, установив правильный заголовок:
  w.Header().Set("Content-Type", "application/json")
  w.Write([]byte(`{"name":"Alex"}`))
