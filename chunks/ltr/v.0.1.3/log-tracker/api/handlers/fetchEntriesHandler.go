package handlers

import (
	"api/dbops"
	"encoding/json"
	"net/http"
	"time"
)

type LogEntry struct {
	SeqNum string
	TmStmp time.Time // timestamp
	SrcIP  string    // source IP address
	Len    string
	Ttl    string
	Id     string // will named 'innerid' in database
	Spt    string // source port
	Dpt    string // destination port
	Window string // will named 'wndw' in database
}

/*
FetchEntriesHandler() handles incoming HTTP requests.

The format of the received request (example):
https://194.58.102.129:8082/logtracker/fetch_entries?source_name=cute_ganymede&start_date=2024-08-21T14:35&end_date=2024-08-22T11:50

parameter names:
- source_name: Name of the source (black_oxygenium or cute_ganymede)
- start_date: Start date and time (ISO 8601) of the data to fetch
- end_date: End date and time (ISO 8601) of the data to fetch
*/
func FetchEntriesHandler(w http.ResponseWriter, r *http.Request) {
	// processURL makes:
	// 	1. checking whether the HTTP request method is a GET method
	// 	2. setting headers
	// 	3. parsing request's parameters and populate r.Form
	err := processURL(w, r)
	if err != nil {
		if err == http.ErrNotSupported {
			http.Error(w, "only GET requests are supported", http.StatusMethodNotAllowed)
		}
		if err == ErrParsingForm {
			http.Error(w, "error parsing form", http.StatusBadRequest)
		}
	}

	// new instance of the fetchEntriesParams struct
	fep := newFetchEntriesParams(w, r)

	err = fep.parseAndValidateDateRange()
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// build SQL query
	fep.buildFetchEntriesSQLString()

	dbConfigFilePath := "config/db-config.json"

	dbCfg, err := dbops.NewDBConfig(dbConfigFilePath, fep.dbName)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	dbCfg.SetDSN() // setting data source name for database connection (sql.Open(driver, dsn))

	// opening database connection
	err = dbCfg.EstablishDbConnection()
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer dbCfg.DB.Close()

	rows, err := dbCfg.DB.Query(fep.preparedQuery)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	// iterate over rows and populate LogEntry structs
	var logEntries []LogEntry
	for rows.Next() {
		var le LogEntry
		err := rows.Scan(&le.SeqNum, &le.TmStmp, &le.SrcIP, &le.Len, &le.Ttl, &le.Id, &le.Spt, &le.Dpt, &le.Window)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		logEntries = append(logEntries, le)
	}

	// send HTTP response
	json.NewEncoder(w).Encode(logEntries) // COOL decision generated by TabNine
}
